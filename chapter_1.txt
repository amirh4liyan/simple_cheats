1
Introduction to Computers,
the Internet and Java
Man is still the most
extraordinary computer of all.
—John F. Kennedy
Good design is good business.
—Thomas J. Watson, Founder of IBM
Objectives
In this chapter you’ll:
Learn about exciting recent
developments in the
computer field.
■ Learn computer hardware,
software and networking
basics.
■ Understand the data
hierarchy.
■ Understand the different
types of programming
languages.
■ Understand the importance
of Java and other leading
programming languages.
■ Understand object-oriented
programming basics.
■ Learn the importance of the
Internet and the web.
■ Learn a typical Java program-
development environment.
■ Test-drive a Java application.
■ Learn some key recent
software technologies.
■ See how to keep up-to-date
with information
technologies.
■2
Chapter 1 Introduction to Computers, the Internet and Java
1.1 Introduction
1.2 Hardware and Software
1.2.1 Moore’s Law
1.2.2 Computer Organization
1.3 Data Hierarchy
1.4 Machine Languages, Assembly
Languages and High-Level Languages
1.5 Introduction to Object Technology
1.5.1 The Automobile as an Object
1.5.2 Methods and Classes
1.5.3 Instantiation
1.5.4 Reuse
1.5.5 Messages and Method Calls
1.5.6 Attributes and Instance Variables
1.5.7 Encapsulation and Information Hiding
1.5.8 Inheritance
1.5.9 Interfaces
1.5.10 Object-Oriented Analysis and Design
(OOAD)
1.5.11 The UML (Unified Modeling
Language)
1.6 Operating Systems
1.6.1 Windows—A Proprietary Operating
System
1.6.2 Linux—An Open-Source Operating
System
1.6.3 Android
1.7 Programming Languages
1.8 Java
1.9 A Typical Java Development
Environment
1.10 Test-Driving a Java Application
1.11 Internet and World Wide Web
1.11.1 The Internet: A Network of Networks
1.11.2 The World Wide Web: Making the
Internet User-Friendly
1.11.3 Web Services and Mashups
1.11.4 Ajax
1.11.5 The Internet of Things
1.12 Software Technologies
1.13 Keeping Up-to-Date with
Information Technologies
Self-Review Exercises | Answers to Self-Review Exercises | Exercises | Making a Difference
1.1 Introduction
Welcome to Java—one of the world’s most widely used computer programming languag-
es. You’re already familiar with the powerful tasks computers perform. Using this text-
book, you’ll write instructions commanding computers to perform those tasks. Software
(i.e., the instructions you write) controls hardware (i.e., computers).
You’ll learn object-oriented programming—today’s key programming methodology.
You’ll create and work with many software objects.
For many organizations, the preferred language for meeting their enterprise program-
ming needs is Java. Java is also widely used for implementing Internet-based applications
and software for devices that communicate over a network.
Forrester Research predicts more than two billion PCs will be in use by 2015.1
According to Oracle, 97% of enterprise desktops, 89% of PC desktops, three billion
devices (Fig. 1.1) and 100% of all Blu-ray DiscTM players run Java, and there are over 9
million Java developers.2
According to a study by Gartner, mobile devices will continue to outpace PCs as users’
primary computing devices; an estimated 1.96 billion smartphones and 388 million tablets
will be shipped in 2015—8.7 times the number of PCs.3 By 2018, the mobile applications
1.
2.
3.
http://www.worldometers.info/computers.
http://www.oracle.com/technetwork/articles/java/javaone12review-1863742.html.
http://www.gartner.com/newsroom/id/2645115.1.1 Introduction
3
Devices
Airplane systems
Blu-ray DiscTM players
Credit cards
e-Readers
Home appliances
Lottery terminals
MRIs
Transportation passes
Smart cards
Smartphones
TV set-top boxes
ATMs
Cable boxes
CT scanners
Game consoles
Home security systems
Medical devices
Parking payment stations
Robots
Smart meters
Tablets
Thermostats
Automobile infotainment systems
Copiers
Desktop computers
GPS navigation systems
Light switches
Mobile phones
Printers
Routers
Smartpens
Televisions
Vehicle diagnostic systems
Fig. 1.1 | Some devices that use Java.
(apps) market is expected to reach $92 billion.4 This is creating significant career opportu-
nities for people who program mobile applications, many of which are programmed in Java
(see Section 1.6.3).
Java Standard Edition
Java has evolved so rapidly that this tenth edition of Java How to Program—based on Java
Standard Edition 7 (Java SE 7) and Java Standard Edition 8 (Java SE 8)—was published
just 17 years after the first edition. Java Standard Edition contains the capabilities needed
to develop desktop and server applications. The book can be used with either Java SE 7 or
Java SE 8 (released just after this book was published). All of the Java SE 8 features are
discussed in modular, easy-to-include-or-omit sections throughout the book.
Prior to Java SE 8, Java supported three programming paradigms—procedural pro-
gramming, object-oriented programming and generic programming. Java SE 8 adds functional
programming. In Chapter 17, we’ll show how to use functional programming to write pro-
grams faster, more concisely, with fewer bugs and that are easier to parallelize (i.e., perform
multiple calculations simultaneously) to take advantage of today’s multi-core hardware
architectures to enhance application performance.
Java Enterprise Edition
Java is used in such a broad spectrum of applications that it has two other editions. The
Java Enterprise Edition (Java EE) is geared toward developing large-scale, distributed net-
working applications and web-based applications. In the past, most computer applications
ran on “standalone” computers (computers that were not networked together). Today’s
applications can be written with the aim of communicating among the world’s computers
via the Internet and the web. Later in this book we discuss how to build such web-based
applications with Java.
4.
https://www.abiresearch.com/press/tablets-will-generate-35-of-this-years-25-
billion-.4
Chapter 1 Introduction to Computers, the Internet and Java
Java Micro Edition
The Java Micro Edition (Java ME)—a subset of Java SE—is geared toward developing
applications for resource-constrained embedded devices, such as smartwatches, MP3 play-
ers, television set-top boxes, smart meters (for monitoring electric energy usage) and more.
1.2 Hardware and Software
Computers can perform calculations and make logical decisions phenomenally faster than
human beings can. Many of today’s personal computers can perform billions of calcula-
tions in one second—more than a human can perform in a lifetime. Supercomputers are
already performing thousands of trillions (quadrillions) of instructions per second! China’s
National University of Defense Technology’s Tianhe-2 supercomputer can perform over
33 quadrillion calculations per second (33.86 petaflops)!5 To put that in perspective, the
Tianhe-2 supercomputer can perform in one second about 3 million calculations for every per-
son on the planet! And—these supercomputing “upper limits” are growing quickly.
Computers process data under the control of sequences of instructions called com-
puter programs. These software programs guide the computer through ordered actions
specified by people called computer programmers. In this book, you’ll learn a key pro-
gramming methodology that’s enhancing programmer productivity, thereby reducing
software development costs—object-oriented programming.
A computer consists of various devices referred to as hardware (e.g., the keyboard,
screen, mouse, hard disks, memory, DVD drives and processing units). Computing costs
are dropping dramatically, owing to rapid developments in hardware and software technol-
ogies. Computers that might have filled large rooms and cost millions of dollars decades
ago are now inscribed on silicon chips smaller than a fingernail, costing perhaps a few dol-
lars each. Ironically, silicon is one of the most abundant materials on Earth—it’s an ingre-
dient in common sand. Silicon-chip technology has made computing so economical that
computers have become a commodity.
1.2.1 Moore’s Law
Every year, you probably expect to pay at least a little more for most products and services.
The opposite has been the case in the computer and communications fields, especially
with regard to the hardware supporting these technologies. For many decades, hardware
costs have fallen rapidly.
Every year or two, the capacities of computers have approximately doubled inexpen-
sively. This remarkable trend often is called Moore’s Law, named for the person who iden-
tified it in the 1960s, Gordon Moore, co-founder of Intel—the leading manufacturer of
the processors in today’s computers and embedded systems. Moore’s Law and related
observations apply especially to the amount of memory that computers have for programs,
the amount of secondary storage (such as disk storage) they have to hold programs and
data over longer periods of time, and their processor speeds—the speeds at which they exe-
cute their programs (i.e., do their work).
5.
http://www.top500.org/.1.2 Hardware and Software
5
Similar growth has occurred in the communications field—costs have plummeted as
enormous demand for communications bandwidth (i.e., information-carrying capacity)
has attracted intense competition. We know of no other fields in which technology
improves so quickly and costs fall so rapidly. Such phenomenal improvement is truly fos-
tering the Information Revolution.
1.2.2 Computer Organization
Regardless of differences in physical appearance, computers can be envisioned as divided
into various logical units or sections (Fig. 1.2).
Logical unitDescription
Input unitThis “receiving” section obtains information (data and computer programs)
from input devices and places it at the disposal of the other units for pro-
cessing. Most user input is entered into computers through keyboards,
touch screens and mouse devices. Other forms of input include receiving
voice commands, scanning images and barcodes, reading from secondary
storage devices (such as hard drives, DVD drives, Blu-ray DiscTM drives and
USB flash drives—also called “thumb drives” or “memory sticks”), receiving
video from a webcam and having your computer receive information from
the Internet (such as when you stream videos from YouTube® or download
e-books from Amazon). Newer forms of input include position data from a
GPS device, and motion and orientation information from an accelerometer
(a device that responds to up/down, left/right and forward/backward accel-
eration) in a smartphone or game controller (such as Microsoft® Kinect®
and Xbox®, WiiTM Remote and Sony® PlayStation® Move).
This “shipping” section takes information the computer has processed and
places it on various output devices to make it available for use outside the
computer. Most information that’s output from computers today is dis-
played on screens (including touch screens), printed on paper (“going
green” discourages this), played as audio or video on PCs and media players
(such as Apple’s iPods) and giant screens in sports stadiums, transmitted
over the Internet or used to control other devices, such as robots and “intel-
ligent” appliances. Information is also commonly output to secondary stor-
age devices, such as hard drives, DVD drives and USB flash drives. A
popular recent form of output is smartphone vibration.
This rapid-access, relatively low-capacity “warehouse” section retains
information that has been entered through the input unit, making it
immediately available for processing when needed. The memory unit also
retains processed information until it can be placed on output devices by
the output unit. Information in the memory unit is volatile—it’s typically
lost when the computer’s power is turned off. The memory unit is often
called either memory, primary memory or RAM (Random Access Mem-
ory). Main memories on desktop and notebook computers contain as much
as 128 GB of RAM. GB stands for gigabytes; a gigabyte is approximately
one billion bytes. A byte is eight bits. A bit is either a 0 or a 1.
Output unit
Memory unit
Fig. 1.2 | Logical units of a computer. (Part 1 of 2.)6
Chapter 1 Introduction to Computers, the Internet and Java
Logical unitDescription
Arithmetic
and logic unit
(ALU)This “manufacturing” section performs calculations, such as addition, sub-
traction, multiplication and division. It also contains the decision mecha-
nisms that allow the computer, for example, to compare two items from the
memory unit to determine whether they’re equal. In today’s systems, the
ALU is implemented as part of the next logical unit, the CPU.
This “administrative” section coordinates and supervises the operation of
the other sections. The CPU tells the input unit when information should
be read into the memory unit, tells the ALU when information from the
memory unit should be used in calculations and tells the output unit when
to send information from the memory unit to certain output devices. Many
of today’s computers have multiple CPUs and, hence, can perform many
operations simultaneously. A multi-core processor implements multiple
processors on a single integrated-circuit chip—a dual-core processor has two
CPUs and a quad-core processor has four CPUs. Today’s desktop computers
have processors that can execute billions of instructions per second.
This is the long-term, high-capacity “warehousing” section. Programs or
data not actively being used by the other units normally are placed on sec-
ondary storage devices (e.g., your hard drive) until they’re again needed,
possibly hours, days, months or even years later. Information on secondary
storage devices is persistent—it’s preserved even when the computer’s power
is turned off. Secondary storage information takes much longer to access
than information in primary memory, but its cost per unit is much less.
Examples of secondary storage devices include hard drives, DVD drives and
USB flash drives, some of which can hold over 2 TB (TB stands for tera-
bytes; a terabyte is approximately one trillion bytes). Typical hard drives on
desktop and notebook computers hold up to 2 TB, and some desktop hard
drives can hold up to 4 TB.
Central
processing
unit (CPU)
Secondary
storage unit
Fig. 1.2 | Logical units of a computer. (Part 2 of 2.)
1.3 Data Hierarchy
Data items processed by computers form a data hierarchy that becomes larger and more
complex in structure as we progress from the simplest data items (called “bits”) to richer
ones, such as characters and fields. Figure 1.3 illustrates a portion of the data hierarchy.
Bits
The smallest data item in a computer can assume the value 0 or the value 1. It’s called a
bit (short for “binary digit”—a digit that can assume one of two values). Remarkably, the
impressive functions performed by computers involve only the simplest manipulations of
0s and 1s—examining a bit’s value, setting a bit’s value and reversing a bit’s value (from 1 to
0 or from 0 to 1).
Characters
It’s tedious for people to work with data in the low-level form of bits. Instead, they prefer
to work with decimal digits (0–9), letters (A–Z and a–z), and special symbols (e.g., $, @, %,1.3 Data Hierarchy
SallyBlack
TomBlue
JudyGreen
IrisOrange
RandyRed
JudyGreen
J u d yField
00000000 01001010
1
7
File
Record
Unicode character J
Bit
Fig. 1.3 | Data hierarchy.
&, *, (, ), –, +, ", :, ? and /). Digits, letters and special symbols are known as characters.
The computer’s character set is the set of all the characters used to write programs and
represent data items. Computers process only 1s and 0s, so a computer’s character set rep-
resents every character as a pattern of 1s and 0s. Java uses Unicode® characters that are
composed of one, two or four bytes (8, 16 or 32 bits). Unicode contains characters for
many of the world’s languages. See Appendix H for more information on Unicode. See
Appendix B for more information on the ASCII (American Standard Code for Informa-
tion Interchange) character set—the popular subset of Unicode that represents uppercase
and lowercase letters, digits and some common special characters.
Fields
Just as characters are composed of bits, fields are composed of characters or bytes. A field
is a group of characters or bytes that conveys meaning. For example, a field consisting of
uppercase and lowercase letters can be used to represent a person’s name, and a field con-
sisting of decimal digits could represent a person’s age.
Records
Several related fields can be used to compose a record (implemented as a class in Java). In
a payroll system, for example, the record for an employee might consist of the following
fields (possible types for these fields are shown in parentheses):8
Chapter 1 Introduction to Computers, the Internet and Java
•Employee identification number (a whole number)
•Name (a string of characters)
•Address (a string of characters)
•Hourly pay rate (a number with a decimal point)
•Year-to-date earnings (a number with a decimal point)
•Amount of taxes withheld (a number with a decimal point)
Thus, a record is a group of related fields. In the preceding example, all the fields belong to
the same employee. A company might have many employees and a payroll record for each.
Files
A file is a group of related records. [Note: More generally, a file contains arbitrary data in
arbitrary formats. In some operating systems, a file is viewed simply as a sequence of bytes—
any organization of the bytes in a file, such as organizing the data into records, is a view
created by the application programmer. You’ll see how to do that in Chapter 15.] It’s not
unusual for an organization to have many files, some containing billions, or even trillions,
of characters of information.
Database
A database is a collection of data organized for easy access and manipulation. The most
popular model is the relational database, in which data is stored in simple tables. A table
includes records and fields. For example, a table of students might include first name, last
name, major, year, student ID number and grade point average fields. The data for each
student is a record, and the individual pieces of information in each record are the fields.
You can search, sort and otherwise manipulate the data based on its relationship to multiple
tables or databases. For example, a university might use data from the student database in
combination with data from databases of courses, on-campus housing, meal plans, etc. We
discuss databases in Chapter 24.
Big Data
The amount of data being produced worldwide is enormous and growing quickly. Accord-
ing to IBM, approximately 2.5 quintillion bytes (2.5 exabytes) of data are created daily and
90% of the world’s data was created in just the past two years!6 According to a Digital Uni-
verse study, the global data supply reached 2.8 zettabytes (equal to 2.8 trillion gigabytes)
in 2012.7 Figure 1.4 shows some common byte measurements. Big data applications deal
with such massive amounts of data and this field is growing quickly, creating lots of op-
portunity for software developers. According to a study by Gartner Group, over 4 million
IT jobs globally will support big data by by 2015.8
6.
7.
8.
http://www-01.ibm.com/software/data/bigdata/.
http://www.guardian.co.uk/news/datablog/2012/dec/19/big-data-study-digital-
universe-global-volume.
http://tech.fortune.cnn.com/2013/09/04/big-data-employment-boom/.1.4 Machine Languages, Assembly Languages and High-Level Languages
UnitBytesWhich is approximately
1 kilobyte (KB)
1 megabyte (MB)
1 gigabyte (GB)
1 terabyte (TB)
1 petabyte (PB)
1 exabyte (EB)
1 zettabyte (ZB)1024 bytes
1024 kilobytes
1024 megabytes
1024 gigabytes
1024 terabytes
1024 petabytes
1024 exabytes103 (1024 bytes exactly)
106 (1,000,000 bytes)
109 (1,000,000,000 bytes)
1012 (1,000,000,000,000 bytes)
1015 (1,000,000,000,000,000 bytes)
1018 (1,000,000,000,000,000,000 bytes)
1021 (1,000,000,000,000,000,000,000 bytes)
9
Fig. 1.4 | Byte measurements.
1.4 Machine Languages, Assembly Languages and High-
Level Languages
Programmers write instructions in various programming languages, some directly under-
standable by computers and others requiring intermediate translation steps. Hundreds of
such languages are in use today. These may be divided into three general types:
1. Machine languages
2. Assembly languages
3. High-level languages
Machine Languages
Any computer can directly understand only its own machine language, defined by its
hardware design. Machine languages generally consist of strings of numbers (ultimately re-
duced to 1s and 0s) that instruct computers to perform their most elementary operations
one at a time. Machine languages are machine dependent (a particular machine language
can be used on only one type of computer). Such languages are cumbersome for humans.
For example, here’s a section of an early machine-language payroll program that adds over-
time pay to base pay and stores the result in gross pay:
+1300042774
+1400593419
+1200274027
Assembly Languages and Assemblers
Programming in machine language was simply too slow and tedious for most program-
mers. Instead of using the strings of numbers that computers could directly understand,
programmers began using English-like abbreviations to represent elementary operations.
These abbreviations formed the basis of assembly languages. Translator programs called as-
semblers were developed to convert early assembly-language programs to machine lan-
guage at computer speeds. The following section of an assembly-language payroll program
also adds overtime pay to base pay and stores the result in gross pay:
load
add
store
basepay
overpay
grosspay10
Chapter 1
Introduction to Computers, the Internet and Java
Although such code is clearer to humans, it’s incomprehensible to computers until trans-
lated to machine language.
High-Level Languages and Compilers
With the advent of assembly languages, computer usage increased rapidly, but program-
mers still had to use numerous instructions to accomplish even the simplest tasks. To
speed the programming process, high-level languages were developed in which single
statements could be written to accomplish substantial tasks. Translator programs called
compilers convert high-level language programs into machine language. High-level lan-
guages allow you to write instructions that look almost like everyday English and contain
commonly used mathematical notations. A payroll program written in a high-level lan-
guage might contain a single statement such as
grossPay = basePay + overTimePay
From the programmer’s standpoint, high-level languages are preferable to machine and
assembly languages. Java is one of the most widely used high-level programming languages.
Interpreters
Compiling a large high-level language program into machine language can take consider-
able computer time. Interpreter programs, developed to execute high-level language pro-
grams directly, avoid the delay of compilation, although they run slower than compiled
programs. We’ll say more about interpreters in Section 1.9, where you’ll learn that Java uses
a clever performance-tuned mixture of compilation and interpretation to run programs.
1.5 Introduction to Object Technology
Today, as demands for new and more powerful software are soaring, building software
quickly, correctly and economically remains an elusive goal. Objects, or more precisely, the
classes objects come from, are essentially reusable software components. There are date ob-
jects, time objects, audio objects, video objects, automobile objects, people objects, etc. Al-
most any noun can be reasonably represented as a software object in terms of attributes
(e.g., name, color and size) and behaviors (e.g., calculating, moving and communicating).
Software-development groups can use a modular, object-oriented design-and-implemen-
tation approach to be much more productive than with earlier popular techniques like
“structured programming”—object-oriented programs are often easier to understand, cor-
rect and modify.
1.5.1 The Automobile as an Object
To help you understand objects and their contents, let’s begin with a simple analogy. Sup-
pose you want to drive a car and make it go faster by pressing its accelerator pedal. What must
happen before you can do this? Well, before you can drive a car, someone has to design it.
A car typically begins as engineering drawings, similar to the blueprints that describe the
design of a house. These drawings include the design for an accelerator pedal. The pedal
hides from the driver the complex mechanisms that actually make the car go faster, just as
the brake pedal “hides” the mechanisms that slow the car, and the steering wheel “hides”
the mechanisms that turn the car. This enables people with little or no knowledge of how
engines, braking and steering mechanisms work to drive a car easily.1.5 Introduction to Object Technology
11
Just as you cannot cook meals in the kitchen of a blueprint, you cannot drive a car’s
engineering drawings. Before you can drive a car, it must be built from the engineering
drawings that describe it. A completed car has an actual accelerator pedal to make it go
faster, but even that’s not enough—the car won’t accelerate on its own (hopefully!), so the
driver must press the pedal to accelerate the car.
1.5.2 Methods and Classes
Let’s use our car example to introduce some key object-oriented programming concepts. Per-
forming a task in a program requires a method. The method houses the program statements
that actually perform its tasks. The method hides these statements from its user, just as the
accelerator pedal of a car hides from the driver the mechanisms of making the car go faster.
In Java, we create a program unit called a class to house the set of methods that perform the
class’s tasks. For example, a class that represents a bank account might contain one method
to deposit money to an account, another to withdraw money from an account and a third to
inquire what the account’s current balance is. A class is similar in concept to a car’s engineer-
ing drawings, which house the design of an accelerator pedal, steering wheel, and so on.
1.5.3 Instantiation
Just as someone has to build a car from its engineering drawings before you can actually
drive a car, you must build an object of a class before a program can perform the tasks that
the class’s methods define. The process of doing this is called instantiation. An object is
then referred to as an instance of its class.
1.5.4 Reuse
Just as a car’s engineering drawings can be reused many times to build many cars, you can
reuse a class many times to build many objects. Reuse of existing classes when building new
classes and programs saves time and effort. Reuse also helps you build more reliable and
effective systems, because existing classes and components often have undergone extensive
testing, debugging and performance tuning. Just as the notion of interchangeable parts was
crucial to the Industrial Revolution, reusable classes are crucial to the software revolution
that has been spurred by object technology.
Software Engineering Observation 1.1
Use a building-block approach to creating your programs. Avoid reinventing the wheel—
use existing high-quality pieces wherever possible. This software reuse is a key benefit of
object-oriented programming.
1.5.5 Messages and Method Calls
When you drive a car, pressing its gas pedal sends a message to the car to perform a task—
that is, to go faster. Similarly, you send messages to an object. Each message is implemented
as a method call that tells a method of the object to perform its task. For example, a pro-
gram might call a bank-account object’s deposit method to increase the account’s balance.
1.5.6 Attributes and Instance Variables
A car, besides having capabilities to accomplish tasks, also has attributes, such as its color,
its number of doors, the amount of gas in its tank, its current speed and its record of total12
Chapter 1
Introduction to Computers, the Internet and Java
miles driven (i.e., its odometer reading). Like its capabilities, the car’s attributes are repre-
sented as part of its design in its engineering diagrams (which, for example, include an
odometer and a fuel gauge). As you drive an actual car, these attributes are carried along
with the car. Every car maintains its own attributes. For example, each car knows how
much gas is in its own gas tank, but not how much is in the tanks of other cars.
An object, similarly, has attributes that it carries along as it’s used in a program. These
attributes are specified as part of the object’s class. For example, a bank-account object has
a balance attribute that represents the amount of money in the account. Each bank-
account object knows the balance in the account it represents, but not the balances of the
other accounts in the bank. Attributes are specified by the class’s instance variables.
1.5.7 Encapsulation and Information Hiding
Classes (and their objects) encapsulate, i.e., encase, their attributes and methods. A class’s
(and its object’s) attributes and methods are intimately related. Objects may communicate
with one another, but they’re normally not allowed to know how other objects are imple-
mented—implementation details are hidden within the objects themselves. This informa-
tion hiding, as we’ll see, is crucial to good software engineering.
1.5.8 Inheritance
A new class of objects can be created conveniently by inheritance—the new class (called
the subclass) starts with the characteristics of an existing class (called the superclass), pos-
sibly customizing them and adding unique characteristics of its own. In our car analogy,
an object of class “convertible” certainly is an object of the more general class “automo-
bile,” but more specifically, the roof can be raised or lowered.
1.5.9 Interfaces
Java also supports interfaces—collections of related methods that typically enable you to
tell objects what to do, but not how to do it (we’ll see an exception to this in Java SE 8).
In the car analogy, a “basic-driving-capabilities” interface consisting of a steering wheel, an
accelerator pedal and a brake pedal would enable a driver to tell the car what to do. Once
you know how to use this interface for turning, accelerating and braking, you can drive
many types of cars, even though manufacturers may implement these systems differently.
A class implements zero or more interfaces, each of which can have one or more
methods, just as a car implements separate interfaces for basic driving functions, control-
ling the radio, controlling the heating and air conditioning systems, and the like. Just as
car manufacturers implement capabilities differently, classes may implement an interface’s
methods differently. For example a software system may include a “backup” interface that
offers the methods save and restore. Classes may implement those methods differently,
depending on the types of things being backed up, such as programs, text, audios, videos,
etc., and the types of devices where these items will be stored.
1.5.10 Object-Oriented Analysis and Design (OOAD)
Soon you’ll be writing programs in Java. How will you create the code (i.e., the program
instructions) for your programs? Perhaps, like many programmers, you’ll simply turn on1.6 Operating Systems
13
your computer and start typing. This approach may work for small programs (like the ones
we present in the early chapters of the book), but what if you were asked to create a soft-
ware system to control thousands of automated teller machines for a major bank? Or sup-
pose you were asked to work on a team of 1,000 software developers building the next
generation of the U.S. air traffic control system? For projects so large and complex, you
should not simply sit down and start writing programs.
To create the best solutions, you should follow a detailed analysis process for deter-
mining your project’s requirements (i.e., defining what the system is supposed to do) and
developing a design that satisfies them (i.e., specifying how the system should do it). Ide-
ally, you’d go through this process and carefully review the design (and have your design
reviewed by other software professionals) before writing any code. If this process involves
analyzing and designing your system from an object-oriented point of view, it’s called an
object-oriented analysis-and-design (OOAD) process. Languages like Java are object ori-
ented. Programming in such a language, called object-oriented programming (OOP),
allows you to implement an object-oriented design as a working system.
1.5.11 The UML (Unified Modeling Language)
Although many different OOAD processes exist, a single graphical language for commu-
nicating the results of any OOAD process has come into wide use. The Unified Modeling
Language (UML) is now the most widely used graphical scheme for modeling object-ori-
ented systems. We present our first UML diagrams in Chapters 3 and 4, then use them in
our deeper treatment of object-oriented programming through Chapter 11. In our option-
al online ATM Software Engineering Case Study in Chapters 33–34 we present a simple
subset of the UML’s features as we guide you through an object-oriented design experience.
1.6 Operating Systems
Operating systems are software systems that make using computers more convenient for us-
ers, application developers and system administrators. They provide services that allow each
application to execute safely, efficiently and concurrently (i.e., in parallel) with other applica-
tions. The software that contains the core components of the operating system is the kernel.
Popular desktop operating systems include Linux, Windows and Mac OS X. Popular mobile
operating systems used in smartphones and tablets include Google’s Android, Apple’s iOS
(for its iPhone, iPad and iPod Touch devices), Windows Phone 8 and BlackBerry OS.
1.6.1 Windows—A Proprietary Operating System
In the mid-1980s, Microsoft developed the Windows operating system, consisting of a
graphical user interface built on top of DOS—an enormously popular personal-computer
operating system that users interacted with by typing commands. Windows borrowed
many concepts (such as icons, menus and windows) popularized by early Apple Macintosh
operating systems and originally developed by Xerox PARC. Windows 8 is Microsoft’s lat-
est operating system—its features include PC and tablet support, a tiles-based user inter-
face, security enhancements, touch-screen and multi-touch support, and more. Windows
is a proprietary operating system—it’s controlled by Microsoft exclusively. It’s by far the
world’s most widely used operating system.14
Chapter 1
Introduction to Computers, the Internet and Java
1.6.2 Linux—An Open-Source Operating System
The Linux operating system—which is popular in servers, personal computers and embed-
ded systems—is perhaps the greatest success of the open-source movement. The open-
source software development style departs from the proprietary development style (used,
for example, with Microsoft’s Windows and Apple’s Mac OS X). With open-source de-
velopment, individuals and companies—often worldwide—contribute their efforts in de-
veloping, maintaining and evolving software. Anyone can use and customize it for their
own purposes, typically at no charge. The Java Development Kit and many related Java
technologies are now open source.
Some organizations in the open-source community are the Eclipse Foundation (the
Eclipse Integrated Development Environment helps Java programmers conveniently develop
software), the Mozilla Foundation (creators of the Firefox web browser), the Apache Software
Foundation (creators of the Apache web server that delivers web pages over the Internet in
response to web-browser requests) and GitHub and SourceForge (which provide the tools
for managing open-source projects).
Rapid improvements to computing and communications, decreasing costs and open-
source software have made it easier and more economical to create software-based busi-
nesses now than just a few decades ago. Facebook, which was launched from a college
dorm room, was built with open-source software.9
A variety of issues—such as Microsoft’s market power, the relatively small number of
user-friendly Linux applications and the diversity of Linux distributions (Red Hat Linux,
Ubuntu Linux and many others)—have prevented widespread Linux use on desktop com-
puters. But Linux has become extremely popular on servers and in embedded systems,
such as Google’s Android-based smartphones.
1.6.3 Android
Android—the fastest-growing mobile and smartphone operating system—is based on the
Linux kernel and uses Java. Experienced Java programmers can quickly dive into Android
development. One benefit of developing Android apps is the openness of the platform.
The operating system is open source and free.
The Android operating system was developed by Android, Inc., which was acquired
by Google in 2005. In 2007, the Open Handset AllianceTM—which now has 87 company
members worldwide (http://www.openhandsetalliance.com/oha_members.html)—
was formed to develop, maintain and evolve Android, driving innovation in mobile tech-
nology and improving the user experience while reducing costs. As of April 2013, more
than 1.5 million Android devices (smartphones, tablets, etc.) were being activated daily.10
By October 2013, a Strategy Analytics report showed that Android had 81.3% of the
global smartphone market share, compared to 13.4% for Apple, 4.1% for Microsoft and
1% for Blackberry.11 Android devices now include smartphones, tablets, e-readers, robots,
jet engines, NASA satellites, game consoles, refrigerators, televisions, cameras, health-care
9. http://developers.facebook.com/opensource.
10. http://www.technobuffalo.com/2013/04/16/google-daily-android-activations-1-5-
million/.
11. http://blogs.strategyanalytics.com/WSS/post/2013/10/31/Android-Captures-Record-
81-Percent-Share-of-Global-Smartphone-Shipments-in-Q3-2013.aspx.1.7 Programming Languages
15
devices, smartwatches, automobile in-vehicle infotainment systems (for controlling the
radio, GPS, phone calls, thermostat, etc.) and more.12
Android smartphones include the functionality of a mobile phone, Internet client (for
web browsing and Internet communication), MP3 player, gaming console, digital camera
and more. These handheld devices feature full-color multitouch screens which allow you to
control the device with gestures involving one touch or multiple simultaneous touches. You
can download apps directly onto your Android device through Google Play and other app
marketplaces. At the time of this writing, there were over one million apps in Google Play,
and the number is growing quickly.13
We present an introduction to Android app development in our textbook, Android How
to Program, Second Edition, and in our professional book, Android for Programmers: An App-
Driven Approach, Second Edition. After you learn Java, you’ll find it straightforward to begin
developing and running Android apps. You can place your apps on Google Play
(play.google.com), and if they’re successful, you may even be able to launch a business. Just
remember—Facebook, Microsoft and Dell were all launched from college dorm rooms.
1.7 Programming Languages
In this section, we comment briefly on several popular programming languages (Fig. 1.5).
In the next section, we introduce Java.
Programming
language
Fortran
COBOL
Pascal
Description
Fortran (FORmula TRANslator) was developed by IBM Corporation in the mid-
1950s for scientific and engineering applications that require complex mathematical
computations. It’s still widely used, and its latest versions support object-oriented
programming.
COBOL (COmmon Business Oriented Language) was developed in the late 1950s
by computer manufacturers, the U.S. government and industrial computer users
based on a language developed by Grace Hopper, a U.S. Navy Rear Admiral and
computer scientist who also advocated for the international standardization of pro-
gramming languages. COBOL is still widely used for commercial applications that
require precise and efficient manipulation of large amounts of data. Its latest version
supports object-oriented programming.
Research in the 1960s resulted in structured programming—a disciplined approach to
writing programs that are clearer, easier to test and debug and easier to modify than
large programs produced with previous techniques. One result of this research was
the development in 1971 of the Pascal programming language, which was designed
for teaching structured programming and was popular in college courses for several
decades.
Fig. 1.5 | Some other programming languages. (Part 1 of 3.)
12. http://www.businessweek.com/articles/2013-05-29/behind-the-internet-of-things-
is-android-and-its-everywhere.
13. http://en.wikipedia.org/wiki/Google_Play.16
Chapter 1
Programming
language
Ada
Basic
C
C++
Objective-C
Visual Basic
Visual C#
PHP
Perl
Python
JavaScript
Introduction to Computers, the Internet and Java
Description
Ada, based on Pascal, was developed under the sponsorship of the U.S. Department
of Defense (DOD) during the 1970s and early 1980s. The DOD wanted a single
language that would fill most of its needs. The Ada language was named after Lady
Ada Lovelace, daughter of the poet Lord Byron. She’s credited with writing the
world’s first computer program in the early 1800s (for the Analytical Engine
mechanical computing device designed by Charles Babbage). Ada also supports
object-oriented programming.
Basic was developed in the 1960s at Dartmouth College to familiarize novices with
programming techniques. Many of its latest versions are object oriented.
C was developed in the early 1970s by Dennis Ritchie at Bell Laboratories. It initially
became widely known as the UNIX operating system’s development language. Today,
most of the code for general-purpose operating systems is written in C or C++.
C++, which is based on C, was developed by Bjarne Stroustrup in the early 1980s at
Bell Laboratories. C++ provides several features that “spruce up” the C language, but
more important, it provides capabilities for object-oriented programming.
Objective-C is another object-oriented language based on C. It was developed in the
early 1980s and later acquired by NeXT, which in turn was acquired by Apple. It has
become the key programming language for the OS X operating system and all iOS-
powered devices (such as iPods, iPhones and iPads).
Microsoft’s Visual Basic language was introduced in the early 1990s to simplify the
development of Microsoft Windows applications. Its latest versions support object-
oriented programming.
Microsoft’s three object-oriented primary programming languages are Visual Basic
(based on the original Basic), Visual C++ (based on C++) and Visual C# (based on
C++ and Java, and developed for integrating the Internet and the web into computer
applications).
PHP, an object-oriented, open-source scripting language supported by a community
of users and developers, is used by millions of websites. PHP is platform indepen-
dent—implementations exist for all major UNIX, Linux, Mac and Windows operat-
ing systems. PHP also supports many databases, including the popular open-source
MySQL.
Perl (Practical Extraction and Report Language), one of the most widely used object-
oriented scripting languages for web programming, was developed in 1987 by Larry
Wall. It features rich text-processing capabilities.
Python, another object-oriented scripting language, was released publicly in 1991.
Developed by Guido van Rossum of the National Research Institute for Mathemat-
ics and Computer Science in Amsterdam (CWI), Python draws heavily from Mod-
ula-3—a systems programming language. Python is “extensible”—it can be extended
through classes and programming interfaces.
JavaScript is the most widely used scripting language. It’s primarily used to add
dynamic behavior to web pages—for example, animations and improved interactiv-
ity with the user. It’s provided with all major web browsers.
Fig. 1.5 | Some other programming languages. (Part 2 of 3.)1.8 Java
Programming
language
Ruby on Rails
17
Description
Ruby, created in the mid-1990s, is an open-source, object-oriented programming
language with a simple syntax that’s similar to Python. Ruby on Rails combines the
scripting language Ruby with the Rails web application framework developed by
37Signals. Their book, Getting Real (gettingreal.37signals.com/toc.php), is a
must read for web developers. Many Ruby on Rails developers have reported pro-
ductivity gains over other languages when developing database-intensive web appli-
cations.
Fig. 1.5 | Some other programming languages. (Part 3 of 3.)
1.8 Java
The microprocessor revolution’s most important contribution to date is that it enabled the
development of personal computers. Microprocessors have had a profound impact in in-
telligent consumer-electronic devices. Recognizing this, Sun Microsystems in 1991 fund-
ed an internal corporate research project led by James Gosling, which resulted in a C++-
based object-oriented programming language that Sun called Java.
A key goal of Java is to be able to write programs that will run on a great variety of
computer systems and computer-controlled devices. This is sometimes called “write once,
run anywhere.”
The web exploded in popularity in 1993, and Sun saw the potential of using Java to
add dynamic content, such as interactivity and animations, to web pages. Java drew the
attention of the business community because of the phenomenal interest in the web. Java
is now used to develop large-scale enterprise applications, to enhance the functionality of
web servers (the computers that provide the content we see in our web browsers), to pro-
vide applications for consumer devices (cell phones, smartphones, television set-top boxes
and more) and for many other purposes. Java is also the key language for developing
Android smartphone and tablet apps. Sun Microsystems was acquired by Oracle in 2010.
Java Class Libraries
You can create each class and method you need to form your Java programs. However,
most Java programmers take advantage of the rich collections of existing classes and meth-
ods in the Java class libraries, also known as the Java APIs (Application Programming
Interfaces).
Performance Tip 1.1
Using Java API classes and methods instead of writing your own versions can improve pro-
gram performance, because they’re carefully written to perform efficiently. This also short-
ens program development time.
1.9 A Typical Java Development Environment
We now explain the steps to create and execute a Java application. Normally there are five
phases—edit, compile, load, verify and execute. We discuss them in the context of the Java18
Chapter 1
Introduction to Computers, the Internet and Java
SE 8 Development Kit (JDK). See the Before You Begin section for information on down-
loading and installing the JDK on Windows, Linux and OS X.
Phase 1: Creating a Program
Phase 1 consists of editing a file with an editor program, normally known simply as an editor
(Fig. 1.6). Using the editor, you type a Java program (typically referred to as source code),
make any necessary corrections and save it on a secondary storage device, such as your hard
drive. Java source code files are given a name ending with the .java extension, indicating
that the file contains Java source code.
Phase 1: Edit
Editor
Disk
Program is created in an
editor and stored on disk in
a file whose name ends
with .java
Fig. 1.6 | Typical Java development environment—editing phase.
Two editors widely used on Linux systems are vi and emacs. Windows provides
Notepad. OS X provides TextEdit. Many freeware and shareware editors are also available
online, including Notepad++ (notepad-plus-plus.org), EditPlus (www.editplus.com),
TextPad (www.textpad.com) and jEdit (www.jedit.org).
Integrated development environments (IDEs) provide tools that support the soft-
ware development process, such as editors, debuggers for locating logic errors (errors that
cause programs to execute incorrectly) and more. There are many popular Java IDEs,
including:
•Eclipse (www.eclipse.org)
•NetBeans (www.netbeans.org)
•IntelliJ IDEA (www.jetbrains.com)
On the book’s website at
www.deitel.com/books/jhtp10
we provide Dive-Into® videos that show you how to executes this book’s Java applications
and how to develop new Java applications with Eclipse, NetBeans and IntelliJ IDEA.
Phase 2: Compiling a Java Program into Bytecodes
In Phase 2, you use the command javac (the Java compiler) to compile a program
(Fig. 1.7). For example, to compile a program called Welcome.java, you’d type
javac Welcome.java
in your system’s command window (i.e., the Command Prompt in Windows, the Terminal
application in OS X) or a Linux shell (also called Terminal in some versions of Linux). If
the program compiles, the compiler produces a .class file called Welcome.class that
contains the compiled version. IDEs typically provide a menu item, such as Build or Make,
that invokes the javac command for you. If the compiler detects errors, you’ll need to go
back to Phase 1 and correct them. In Chapter 2, we’ll say more about the kinds of errors
the compiler can detect.1.9 A Typical Java Development Environment
Phase 2: Compile
Compiler
Disk
19
Compiler creates bytecodes
and stores them on disk in a
file whose name ends
with .class
Fig. 1.7 | Typical Java development environment—compilation phase.
The Java compiler translates Java source code into bytecodes that represent the tasks
to execute in the execution phase (Phase 5). The Java Virtual Machine (JVM)—a part of
the JDK and the foundation of the Java platform—executes bytecodes. A virtual machine
(VM) is a software application that simulates a computer but hides the underlying oper-
ating system and hardware from the programs that interact with it. If the same VM is
implemented on many computer platforms, applications written for that type of VM can
be used on all those platforms. The JVM is one of the most widely used virtual machines.
Microsoft’s .NET uses a similar virtual-machine architecture.
Unlike machine-language instructions, which are platform dependent (that is, depen-
dent on specific computer hardware), bytecode instructions are platform independent. So,
Java’s bytecodes are portable—without recompiling the source code, the same bytecode
instructions can execute on any platform containing a JVM that understands the version
of Java in which the bytecodes were compiled. The JVM is invoked by the java command.
For example, to execute a Java application called Welcome, you’d type the command
java Welcome
in a command window to invoke the JVM, which would then initiate the steps necessary
to execute the application. This begins Phase 3. IDEs typically provide a menu item, such
as Run, that invokes the java command for you.
Phase 3: Loading a Program into Memory
In Phase 3, the JVM places the program in memory to execute it—this is known as loading
(Fig. 1.8).The JVM’s class loader takes the .class files containing the program’s byte-
codes and transfers them to primary memory. It also loads any of the .class files provided
by Java that your program uses. The .class files can be loaded from a disk on your system
or over a network (e.g., your local college or company network, or the Internet).
Primary
Memory
Phase 3: Load
Class loader reads
Class Loader
.class files
...
Disk
Fig. 1.8 | Typical Java development environment—loading phase.
containing bytecodes
from disk and puts
those bytecodes in
memory20
Chapter 1
Introduction to Computers, the Internet and Java
Phase 4: Bytecode Verification
In Phase 4, as the classes are loaded, the bytecode verifier examines their bytecodes to en-
sure that they’re valid and do not violate Java’s security restrictions (Fig. 1.9). Java enforces
strong security to make sure that Java programs arriving over the network do not damage
your files or your system (as computer viruses and worms might).
Primary
Memory
Phase 4: Verify
Bytecode Verifier
...
Bytecode verifier
confirms that all
bytecodes are valid and
do not violate Java’s
security restrictions
Fig. 1.9 | Typical Java development environment—verification phase.
Phase 5: Execution
In Phase 5, the JVM executes the program’s bytecodes, thus performing the actions specified
by the program (Fig. 1.10). In early Java versions, the JVM was simply an interpreter for Java
bytecodes. Most Java programs would execute slowly, because the JVM would interpret and
execute one bytecode at a time. Some modern computer architectures can execute several in-
structions in parallel. Today’s JVMs typically execute bytecodes using a combination of in-
terpretation and so-called just-in-time (JIT) compilation. In this process, the JVM analyzes
the bytecodes as they’re interpreted, searching for hot spots—parts of the bytecodes that exe-
cute frequently. For these parts, a just-in-time (JIT) compiler, such as Oracle’s Java
HotSpotTM compiler, translates the bytecodes into the underlying computer’s machine lan-
guage. When the JVM encounters these compiled parts again, the faster machine-language
code executes. Thus Java programs actually go through two compilation phases—one in
which source code is translated into bytecodes (for portability across JVMs on different com-
puter platforms) and a second in which, during execution, the bytecodes are translated into
machine language for the actual computer on which the program executes.
Primary
Memory
Phase 5: Execute
Java Virtual Machine (JVM)
...
To execute the program, the
JVM reads bytecodes and
just-in-time (JIT) compiles
(i.e., translates) them into a
language that the computer
can understand. As the
program executes, it may store
data values in primary
memory.
Fig. 1.10 | Typical Java development environment—execution phase.
Problems That May Occur at Execution Time
Programs might not work on the first try. Each of the preceding phases can fail because of
various errors that we’ll discuss throughout this book. For example, an executing program1.10 Test-Driving a Java Application
21
might try to divide by zero (an illegal operation for whole-number arithmetic in Java).
This would cause the Java program to display an error message. If this occurred, you’d
have to return to the edit phase, make the necessary corrections and proceed through the
remaining phases again to determine that the corrections fixed the problem(s). [Note:
Most programs in Java input or output data. When we say that a program displays a mes-
sage, we normally mean that it displays that message on your computer’s screen. Messages
and other data may be output to other devices, such as disks and hardcopy printers, or even
to a network for transmission to other computers.]
Common Programming Error 1.1
Errors such as division by zero occur as a program runs, so they’re called runtime errors
or execution-time errors. Fatal runtime errors cause programs to terminate immediately
without having successfully performed their jobs. Nonfatal runtime errors allow pro-
grams to run to completion, often producing incorrect results.
1.10 Test-Driving a Java Application
In this section, you’ll run and interact with your first Java application. The Painter appli-
cation, which you’ll build over the course of several exercises, allows you to drag the mouse
to “paint.” The elements and functionality you see here are typical of what you’ll learn to
program in this book. Using the Painter’s graphical user interface (GUI), you can control
the drawing color, the shape to draw (line, rectangle or oval) and whether the shape is filled
with the drawing color. You can also undo the last shape you added to the drawing or clear
the entire drawing. [Note: We use fonts to distinguish between features. Our convention
is to emphasize screen features like titles and menus (e.g., the File menu) in a semibold
sans-serif Helvetica font and to emphasize nonscreen elements, such as file names, pro-
gram code or input (e.g., ProgramName.java), in a sans-serif Lucida font.]
The steps in this section show you how to execute the Painter app from a Command
Prompt (Windows), Terminal (OS X) or shell (Linux) window on your system.
Throughout the book, we’ll refer to these windows simply as command windows. Perform
the following steps to use the Painter application to draw a smiley face:
1. Checking your setup. Read the Before You Begin section to confirm that you’ve
set up Java properly on your computer, that you’ve copied the book’s examples
to your hard drive and that you know how to open a command window on your
system.
2. Changing to the completed application’s directory. Open a command window and
use the cd command to change to the directory (also called a folder) for the Painter
application. We assume that the book’s examples are located in C:\examples on
Windows or in your user account’s Documents/examples folder on Linux/OS X.
On Windows type cd C:\examples\ch01\painter, then press Enter. On Linux/
OS X, type cd ~/Documents/examples/ch01/painter, then press Enter.
3. Running the Painter application. Recall that the java command, followed by the
name of the application’s .class file (in this case, Painter), executes the appli-
cation. Type the command java Painter and press Enter to execute the app.
Figure 1.11 shows the app running on Windows, Linux and OS X, respective-
ly—we shortened the windows to save space.22
Chapter 1
Introduction to Computers, the Internet and Java
a) Painter app running on Windows
Close button
Select a color
Select a shapeClear the
entire drawing
Specify
whether a
rectangle or
oval is filled
with colorUndo the last
shape that was
added to the
drawing
b) Painter app running on Linux.
Close
button
c) Painter app running on OS X.
Close
button
Fig. 1.11 | Painter app executing in Windows 7, Linux and OS X.
[Note: Java commands are case sensitive—that is, uppercase letters are different
from lowercase letters. It’s important to type the name of this application as
Painter with a capital P. Otherwise, the application will not execute. Specifying
the .class extension when using the java command results in an error. Also, if
you receive the error message, “Exception in thread "main" java.lang.No-
ClassDefFoundError: Painter," your system has a CLASSPATH problem. Please
refer to the Before You Begin section for instructions to help you fix this problem.]
4. Drawing a filled yellow oval for the face. Select Yellow as the drawing color, Oval
as the shape and check the Filled checkbox, then drag the mouse to draw a large
oval (Fig. 1.12).1.10 Test-Driving a Java Application
23
Fig. 1.12 | Drawing a filled yellow oval for the face.
5. Drawing blue eyes. Select Blue as the drawing color, then draw two small ovals as
the eyes (Fig. 1.13).
Fig. 1.13 | Drawing blue eyes.
6. Drawing black eyebrows and a nose. Select Black as the drawing color and Line
as the shape, then draw eyebrows and a nose (Fig. 1.14). Lines do not have fill,
so leaving the Filled checkbox checked has no effect when drawing lines.24
Chapter 1
Introduction to Computers, the Internet and Java
Fig. 1.14 | Drawing black eyebrows and a nose.
7. Drawing a magenta mouth. Select Magenta as the drawing color and Oval as the
shape, then draw a mouth (Fig. 1.15).
Fig. 1.15 | Drawing a magenta mouth.
8. Drawing a yellow oval on the mouth to make a smile. Select Yellow as the drawing
color, then draw an oval to change the magenta oval into a smile (Fig. 1.16).1.11 Internet and World Wide Web
25
Fig. 1.16 | Drawing a yellow oval on the mouth to make a smile.
9. Exiting the Painter application. To exit the Painter application, click the Close
button (in the window’s upper-right corner on Windows and the upper-left cor-
ner on Linux and OS X). Closing the window causes the Painter application to
terminate.
1.11 Internet and World Wide Web
In the late 1960s, ARPA—the Advanced Research Projects Agency of the United States De-
partment of Defense—rolled out plans for networking the main computer systems of ap-
proximately a dozen ARPA-funded universities and research institutions. The computers
were to be connected with communications lines operating at speeds on the order of 50,000
bits per second, a stunning rate at a time when most people (of the few who even had net-
working access) were connecting over telephone lines to computers at a rate of 110 bits per
second. Academic research was about to take a giant leap forward. ARPA proceeded to im-
plement what quickly became known as the ARPANET, the precursor to today’s Internet.
Today’s fastest Internet speeds are on the order of billions of bits per second with trillion-
bit-per-second speeds on the horizon!
Things worked out differently from the original plan. Although the ARPANET
enabled researchers to network their computers, its main benefit proved to be the capa-
bility for quick and easy communication via what came to be known as electronic mail (e-
mail). This is true even on today’s Internet, with e-mail, instant messaging, file transfer
and social media such as Facebook and Twitter enabling billions of people worldwide to
communicate quickly and easily.
The protocol (set of rules) for communicating over the ARPANET became known as
the Transmission Control Protocol (TCP). TCP ensured that messages, consisting of
sequentially numbered pieces called packets, were properly routed from sender to receiver,
arrived intact and were assembled in the correct order.26
Chapter 1
Introduction to Computers, the Internet and Java
1.11.1 The Internet: A Network of Networks
In parallel with the early evolution of the Internet, organizations worldwide were imple-
menting their own networks for both intraorganization (that is, within an organization)
and interorganization (that is, between organizations) communication. A huge variety of
networking hardware and software appeared. One challenge was to enable these different
networks to communicate with each other. ARPA accomplished this by developing the In-
ternet Protocol (IP), which created a true “network of networks,” the current architecture
of the Internet. The combined set of protocols is now called TCP/IP.
Businesses rapidly realized that by using the Internet, they could improve their oper-
ations and offer new and better services to their clients. Companies started spending large
amounts of money to develop and enhance their Internet presence. This generated fierce
competition among communications carriers and hardware and software suppliers to meet
the increased infrastructure demand. As a result, bandwidth—the information-carrying
capacity of communications lines—on the Internet has increased tremendously, while
hardware costs have plummeted.
1.11.2 The World Wide Web: Making the Internet User-Friendly
The World Wide Web (simply called “the web”) is a collection of hardware and software
associated with the Internet that allows computer users to locate and view multimedia-based
documents (documents with various combinations of text, graphics, animations, audios and
videos) on almost any subject. The introduction of the web was a relatively recent event. In
1989, Tim Berners-Lee of CERN (the European Organization for Nuclear Research) began
to develop a technology for sharing information via “hyperlinked” text documents. Berners-
Lee called his invention the HyperText Markup Language (HTML). He also wrote com-
munication protocols such as HyperText Transfer Protocol (HTTP) to form the backbone
of his new hypertext information system, which he referred to as the World Wide Web.
In 1994, Berners-Lee founded an organization, called the World Wide Web Consor-
tium (W3C, www.w3.org), devoted to developing web technologies. One of the W3C’s
primary goals is to make the web universally accessible to everyone regardless of disabili-
ties, language or culture. In this book, you’ll use Java to build web-based applications.
1.11.3 Web Services and Mashups
In online Chapter 32, we include a substantial treatment of web services (Fig. 1.17). The
applications-development methodology of mashups enables you to rapidly develop power-
ful software applications by combining (often free) complementary web services and other
forms of information feeds. One of the first mashups combined the real-estate listings pro-
vided by www.craigslist.org with the mapping capabilities of Google Maps to offer maps
that showed the locations of homes for sale or rent in a given area.
Web services sourceHow it’s used
Google Maps
TwitterMapping services
Microblogging
Fig. 1.17 | Some popular web services (www.programmableweb.com/apis/
directory/1?sort=mashups). (Part 1 of 2.)1.11 Internet and World Wide Web
Web services sourceHow it’s used
YouTube
Facebook
Instagram
Foursquare
LinkedIn
Groupon
Netflix
eBay
Wikipedia
PayPal
Last.fm
Amazon eCommerce
Salesforce.com
Skype
Microsoft Bing
Flickr
Zillow
Yahoo Search
WeatherBugVideo search
Social networking
Photo sharing
Mobile check-in
Social networking for business
Social commerce
Movie rentals
Internet auctions
Collaborative encyclopedia
Payments
Internet radio
Shopping for books and many other products
Customer Relationship Management (CRM)
Internet telephony
Search
Photo sharing
Real-estate pricing
Search
Weather
27
Fig. 1.17 | Some popular web services (www.programmableweb.com/apis/
directory/1?sort=mashups). (Part 2 of 2.)
1.11.4 Ajax
Ajax helps Internet-based applications perform like desktop applications—a difficult task,
given that such applications suffer transmission delays as data is shuttled back and forth
between your computer and server computers on the Internet. Using Ajax, applications
like Google Maps have achieved excellent performance and approach the look-and-feel of
desktop applications. Although we don’t discuss “raw” Ajax programming (which is quite
complex) in this text, we do show in online Chapter 31 how to build Ajax-enabled appli-
cations using JavaServer Faces (JSF) Ajax-enabled components.
1.11.5 The Internet of Things
The Internet is no longer just a network of computers—it’s an Internet of Things. A thing
is any object with an IP address and the ability to send data automatically over a net-
work—e.g., a car with a transponder for paying tolls, a heart monitor implanted in a hu-
man, a smart meter that reports energy usage, mobile apps that can track your movement
and location, and smart thermostats that adjust room temperatures based on weather fore-
casts and activity in the home. You’ll use IP addresses to build networked applications in
online Chapter 28.28
Chapter 1
Introduction to Computers, the Internet and Java
1.12 Software Technologies
Figure 1.18 lists a number of buzzwords that you’ll hear in the software development com-
munity. We’ve created Resource Centers on most of these topics, with more on the way.
TechnologyDescription
Agile software
developmentAgile software development is a set of methodologies that try to get soft-
ware implemented faster and using fewer resources. Check out the Agile
Alliance (www.agilealliance.org) and the Agile Manifesto
(www.agilemanifesto.org).
Refactoring involves reworking programs to make them clearer and easier to
maintain while preserving their correctness and functionality. It’s widely
employed with agile development methodologies. Many IDEs contain
built-in refactoring tools to do major portions of the reworking automatically.
Design patterns are proven architectures for constructing flexible and
maintainable object-oriented software. The field of design patterns tries to
enumerate those recurring patterns, encouraging software designers to reuse
them to develop better-quality software using less time, money and effort.
We discuss Java design patterns in the online Appendix N.
LAMP is an acronym for the open-source technologies that many develop-
ers use to build web applications—it stands for Linux, Apache, MySQL and
PHP (or Perl or Python—two other scripting languages). MySQL is an
open-source database management system. PHP is the most popular open-
source server-side “scripting” language for developing web applications.
Apache is the most popular web server software. The equivalent for Win-
dows development is WAMP—Windows, Apache, MySQL and PHP.
Software has generally been viewed as a product; most software still is
offered this way. If you want to run an application, you buy a software
package from a software vendor—often a CD, DVD or web download.
You then install that software on your computer and run it as needed. As
new versions appear, you upgrade your software, often at considerable cost
in time and money. This process can become cumbersome for organiza-
tions that must maintain tens of thousands of systems on a diverse array of
computer equipment. With Software as a Service (SaaS), the software runs
on servers elsewhere on the Internet. When that server is updated, all cli-
ents worldwide see the new capabilities—no local installation is needed.
You access the service through a browser. Browsers are quite portable, so
you can run the same applications on a wide variety of computers from
anywhere in the world. Salesforce.com, Google, and Microsoft’s Office Live
and Windows Live all offer SaaS.
Platform as a Service (PaaS) provides a computing platform for developing
and running applications as a service over the web, rather than installing
the tools on your computer. Some PaaS providers are Google App Engine,
Amazon EC2 and Windows AzureTM.
Refactoring
Design patterns
LAMP
Software as a
Service (SaaS)
Platform as a
Service (PaaS)
Fig. 1.18 | Software technologies. (Part 1 of 2.)1.12 Software Technologies
29
TechnologyDescription
Cloud
computingSaaS and PaaS are examples of cloud computing. You can use software and
data stored in the “cloud”—i.e., accessed on remote computers (or servers)
via the Internet and available on demand—rather than having it stored on
your desktop, notebook computer or mobile device. This allows you to
increase or decrease computing resources to meet your needs at any given
time, which is more cost effective than purchasing hardware to provide
enough storage and processing power to meet occasional peak demands.
Cloud computing also saves money by shifting the burden of managing these
apps to the service provider.
Software Development Kits (SDKs) include the tools and documentation
developers use to program applications. For example, you’ll use the Java
Development Kit (JDK) to build and run Java applications.
Software
Development
Kit (SDK)
Fig. 1.18 | Software technologies. (Part 2 of 2.)
Software is complex. Large, real-world software applications can take many months
or even years to design and implement. When large software products are under develop-
ment, they typically are made available to the user communities as a series of releases, each
more complete and polished than the last (Fig. 1.19).
VersionDescription
AlphaAlpha software is the earliest release of a software product that’s still under
active development. Alpha versions are often buggy, incomplete and unstable
and are released to a relatively small number of developers for testing new
features, getting early feedback, etc.
Beta versions are released to a larger number of developers later in the devel-
opment process after most major bugs have been fixed and new features are
nearly complete. Beta software is more stable, but still subject to change.
Release candidates are generally feature complete, (mostly) bug free and ready
for use by the community, which provides a diverse testing environment—
the software is used on different systems, with varying constraints and for a
variety of purposes.
Any bugs that appear in the release candidate are corrected, and eventually
the final product is released to the general public. Software companies often
distribute incremental updates over the Internet.
Software that’s developed using this approach (for example, Google search or
Gmail) generally does not have version numbers. It’s hosted in the cloud (not
installed on your computer) and is constantly evolving so that users always
have the latest version.
Beta
Release
candidates
Final release
Continuous
beta
Fig. 1.19 | Software product-release terminology.30
Chapter 1
Introduction to Computers, the Internet and Java
1.13 Keeping Up-to-Date with Information Technologies
Figure 1.20 lists key technical and business publications that will help you stay up-to-date
with the latest news and trends and technology. You can also find a growing list of Inter-
net- and web-related Resource Centers at www.deitel.com/ResourceCenters.html.
PublicationURL
AllThingsD
Bloomberg BusinessWeek
CNET
Communications of the ACM
Computerworld
Engadget
eWeek
Fast Company
Fortune
GigaOM
Hacker News
IEEE Computer Magazine
InfoWorld
Mashable
PCWorld
SD Times
Slashdot
Technology Review
Techcrunch
The Next Web
The Verge
Wiredallthingsd.com
www.businessweek.com
news.cnet.com
cacm.acm.org
www.computerworld.com
www.engadget.com
www.eweek.com
www.fastcompany.com/
money.cnn.com/magazines/fortune
gigaom.com
news.ycombinator.com
www.computer.org/portal/web/computingnow/computer
www.infoworld.com
mashable.com
www.pcworld.com
www.sdtimes.com
slashdot.org/
technologyreview.com
techcrunch.com
thenextweb.com
www.theverge.com
www.wired.com
Fig. 1.20 | Technical and business publications.
Self-Review Exercises
1.1
Fill in the blanks in each of the following statements:
a) Computers process data under the control of sets of instructions called
.
b) The key logical units of the computer are the
,
,
,
,
and
.
c) The three types of languages discussed in the chapter are
,
and
.
d) The programs that translate high-level language programs into machine language are
called
.Answers to Self-Review Exercises
31
e)
f)
is an operating system for mobile devices based on the Linux kernel and Java.
software is generally feature complete, (supposedly) bug free and ready for use
by the community.
g) The Wii Remote, as well as many smartphones, use a(n)
which allows the de-
vice to respond to motion.
1.2Fill in the blanks in each of the following sentences about the Java environment:
command from the JDK executes a Java application.
a) The
b) The
command from the JDK compiles a Java program.
file extension.
c) A Java source code file must end with the
d) When a Java program is compiled, the file produced by the compiler ends with the
file extension.
that are executed by the Java
e) The file produced by the Java compiler contains
Virtual Machine.
1.3Fill in the blanks in each of the following statements (based on Section 1.5):
a) Objects enable the design practice of
—although they may know how to com-
municate with one another across well-defined interfaces, they normally are not allowed
to know how other objects are implemented.
, which contain fields and the set of
b) Java programmers concentrate on creating
methods that manipulate those fields and provide services to clients.
c) The process of analyzing and designing a system from an object-oriented point of view
is called
.
d) A new class of objects can be created conveniently by
—the new class (called
the subclass) starts with the characteristics of an existing class (called the superclass),
possibly customizing them and adding unique characteristics of its own.
e)
is a graphical language that allows people who design software systems to use
an industry-standard notation to represent them.
of the object’s class.
f) The size, shape, color and weight of an object are considered
Answers to Self-Review Exercises
1.1
a) programs. b) input unit, output unit, memory unit, central processing unit, arithmetic
and logic unit, secondary storage unit. c) machine languages, assembly languages, high-level lan-
guages. d) compilers. e) Android. f) Release candidate. g) accelerometer.
1.2
a)
java. b) javac. c) .java. d) .class. e) bytecodes.
1.3
a) information hiding. b) classes. c) object-oriented analysis and design (OOAD).
d) inheritance. e) The Unified Modeling Language (UML). f) attributes.
Exercises
1.4
Fill in the blanks in each of the following statements:
a) The logical unit that receives information from outside the computer for use by the
.
computer is the
b) The process of instructing the computer to solve a problem is called
.
c)
is a type of computer language that uses Englishlike abbreviations for ma-
chine-language instructions.
is a logical unit that sends information which has already been processed by
d)
the computer to various devices so that it may be used outside the computer.
e)
and
are logical units of the computer that retain information.
f)
is a logical unit of the computer that performs calculations.
g)
is a logical unit of the computer that makes logical decisions.32
Chapter 1
Introduction to Computers, the Internet and Java
h)
languages are most convenient to the programmer for writing programs
quickly and easily.
.
i) The only language a computer can directly understand is that computer’s
j)
is a logical unit of the computer that coordinates the activities of all the other
logical units.
1.5Fill in the blanks in each of the following statements:
programming language is now used to develop large-scale enterprise ap-
a) The
plications, to enhance the functionality of web servers, to provide applications for con-
sumer devices and for many other purposes.
b)
initially became widely known as the development language of the UNIX op-
erating system.
ensures that messages, consisting of sequentially numbered pieces called
c) The
bytes, were properly routed from sender to receiver, arrived intact and were assembled
in the correct order.
d) The
programming language was developed by Bjarne Stroustrup in the early
1980s at Bell Laboratories.
1.6Fill in the blanks in each of the following statements:
,
,
,
a) Java programs normally go through five phases—
and
.
b) A(n)
provides many tools that support the software development process,
such as editors for writing and editing programs, debuggers for locating logic errors in
programs, and many other features.
c) The command java invokes the
, which executes Java programs.
is a software application that simulates a computer, but hides the under-
d) A(n)
lying operating system and hardware from the programs that interact with it.
e) The
takes the .class files containing the program’s bytecodes and transfers
them to primary memory.
examines bytecodes to ensure that they’re valid.
f) The
1.7Explain the two compilation phases of Java programs.
1.8
One of the world’s most common objects is a wrist watch. Discuss how each of the follow-
ing terms and concepts applies to the notion of a watch: object, attributes, behaviors, class, inheri-
tance (consider, for example, an alarm clock), modeling, messages, encapsulation, interface and
information hiding.
Making a Difference
Throughout the book we’ve included Making a Difference exercises in which you’ll be asked to
work on problems that really matter to individuals, communities, countries and the world. For
more information about worldwide organizations working to make a difference, and for related
programming project ideas, visit our Making a Difference Resource Center at www.deitel.com/
makingadifference.
1.9
(Test-Drive: Carbon Footprint Calculator) Some scientists believe that carbon emissions,
especially from the burning of fossil fuels, contribute significantly to global warming and that this
can be combatted if individuals take steps to limit their use of carbon-based fuels. Organizations and
individuals are increasingly concerned about their “carbon footprints.” Websites such as TerraPass
http://www.terrapass.com/carbon-footprint-calculator/
and Carbon Footprint
http://www.carbonfootprint.com/calculator.aspxMaking a Difference
33
provide carbon-footprint calculators. Test-drive these calculators to determine your carbon foot-
print. Exercises in later chapters will ask you to program your own carbon-footprint calculator. To
prepare for this, use the web to research the formulas for calculating carbon footprints.
1.10 (Test-Drive: Body Mass Index Calculator) Obesity causes significant increases in illnesses
such as diabetes and heart disease. To determine whether a person is overweight or obese, you can
use a measure called the body mass index (BMI). The United States Department of Health and Hu-
man Services provides a BMI calculator at http://www.nhlbi.nih.gov/guidelines/obesity/BMI/
bmicalc.htm. Use it to calculate your own BMI. A forthcoming exercise will ask you to program
your own BMI calculator. To prepare for this, use the web to research the formulas for calculating
BMI.
1.11 (Attributes of Hybrid Vehicles) In this chapter you learned some basics of classes. Now you’ll
“flesh out” aspects of a class called “Hybrid Vehicle.” Hybrid vehicles are becoming increasingly
popular, because they often get much better mileage than purely gasoline-powered vehicles. Browse
the web and study the features of four or five of today’s popular hybrid cars, then list as many of
their hybrid-related attributes as you can. Some common attributes include city-miles-per-gallon
and highway-miles-per-gallon. Also list the attributes of the batteries (type, weight, etc.).
1.12 (Gender Neutrality) Many people want to eliminate sexism in all forms of communication.
You’ve been asked to create a program that can process a paragraph of text and replace gender-spe-
cific words with gender-neutral ones. Assuming that you’ve been given a list of gender-specific
words and their gender-neutral replacements (e.g., replace both “wife” and “husband” with
“spouse,” “man” and “woman” with “person,” “daughter” and “son” with “child”), explain the pro-
cedure you’d use to read through a paragraph of text and manually perform these replacements.
How might your procedure generate a strange term like “woperchild?” You’ll soon learn that a more
formal term for “procedure” is “algorithm,” and that an algorithm specifies the steps to be per-
formed and the order in which to perform them. We’ll show how to develop algorithms then con-
vert them to Java programs which can be run on computers.
